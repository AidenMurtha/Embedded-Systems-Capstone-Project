#include <Wire.h>
#include <Adafruit_INA219.h>

// TWO INA219 MODULES
Adafruit_INA219 ina1(0x40);
Adafruit_INA219 ina2(0x41);

// averaging settings
const int sampleInterval = 1000;
const int averagePeriod  = 3000;
const int numSamples     = averagePeriod / sampleInterval;

// Relay setup
const int relayPin = 7;
const bool relayActiveLow = false;

const float trip_mA  = 160.0;
const float reset_mA = 150.0;
const unsigned long inrushIgnoreMs = 500;

// accumulator values
float totalBus1 = 0, totalCurrent1 = 0, totalPower1 = 0;
float totalBus2 = 0, totalCurrent2 = 0, totalPower2 = 0;
int sampleCount = 0;
unsigned long lastSampleTime = 0;
unsigned long lastRelayOnTime = 0;

// ---------- STATE MACHINE ----------
enum SystemState {
  STATE_IDLE,        // relay OFF
  STATE_RELAY_ON,    // relay ON, monitoring
  STATE_TRIPPED      // relay OFF due to overcurrent
};

SystemState state = STATE_IDLE;

enum OffReason { NONE, OVERCURRENT, PS5_OFF };
OffReason offReason = NONE;


void setRelay(bool on) {
  digitalWrite(relayPin, relayActiveLow ? !on : on);
  if (on) lastRelayOnTime = millis();
}


void setup() {
  Serial.begin(115200);
  Serial1.begin(115200);   // <<<<<< ADD THIS FOR TX/RX
  Serial.println("Dual INA219 Monitor + Relay Trip (State Machine)");

  pinMode(relayPin, OUTPUT);

  // Relay starts OFF
  setRelay(false);

  // INA219 setup
  if (!ina1.begin()) {
    Serial.println("INA219 #1 not found!");
    while (1);
  }
  ina1.setCalibration_32V_2A();

  if (!ina2.begin()) {
    Serial.println("INA219 #2 not found!");
    while (1);
  }
  ina2.setCalibration_32V_2A();
}


// Read INA219, accumulate averages
bool sampleSensors(float &avgI1, float &avgV1, float &avgP1, float &avgI2, float &avgV2, float &avgP2) 
{
  unsigned long currentMillis = millis();

  if (currentMillis - lastSampleTime < sampleInterval)
    return false;

  lastSampleTime = currentMillis;

  // Read sensor 1
  float v1 = ina1.getBusVoltage_V();
  float i1 = ina1.getCurrent_mA();
  float p1 = ina1.getPower_mW();

  // Read sensor 2
  float v2 = ina2.getBusVoltage_V();
  float i2 = ina2.getCurrent_mA();
  float p2 = ina2.getPower_mW();

  // Accumulate
  totalBus1    += v1;
  totalCurrent1 += i1;
  totalPower1   += p1;

  totalBus2    += v2;
  totalCurrent2 += i2;
  totalPower2   += p2;

  sampleCount++;

  // Debug live readings
  Serial.print("Sample "); Serial.println(sampleCount);
  Serial.print("INA1 I(mA): "); Serial.print(i1);
  Serial.print("  V: "); Serial.println(v1);

  Serial.print("INA2 I(mA): "); Serial.print(i2);
  Serial.print("  V: "); Serial.println(v2);


  if (sampleCount >= numSamples) {
    avgV1 = totalBus1 / sampleCount;
    avgI1 = totalCurrent1 / sampleCount;
    avgP1 = totalPower1 / sampleCount;

    avgV2 = totalBus2 / sampleCount;
    avgI2 = totalCurrent2 / sampleCount;
    avgP2 = totalPower2 / sampleCount;

    Serial.println("----- 3 Second Averages -----");

    Serial.print("INA1 Avg V: "); Serial.println(avgV1);
    Serial.print("INA1 Avg I: "); Serial.println(avgI1);
    Serial.print("INA1 Avg P: "); Serial.println(avgP1);

    Serial.println();
    Serial.print("INA2 Avg V: "); Serial.println(avgV2);
    Serial.print("INA2 Avg I: "); Serial.println(avgI2);
    Serial.print("INA2 Avg P: "); Serial.println(avgP2);

    Serial.println("-----------------------------");

    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // SEND AVERAGES TO ESP32 VIA SERIAL1 (TX/RX)
    // Format: avgI1,avgV1,avgP1,avgI2,avgV2,avgP2
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    Serial1.print(avgV1); Serial1.print(",");
    Serial1.print(avgI1); Serial1.print(",");
    Serial1.print(avgP1); Serial1.print(",");
    Serial1.print(avgV2); Serial1.print(",");
    Serial1.print(avgI2); Serial1.print(",");
    Serial1.println(avgP2);   // ends with newline
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    // Reset accumulators
    totalBus1 = totalCurrent1 = totalPower1 = 0;
    totalBus2 = totalCurrent2 = totalPower2 = 0;
    sampleCount = 0;

    return true;
  }

  return false;
}


// ------------ STATE HANDLERS ------------
void handleIdle(float avgI1) {
  Serial.println("[STATE_IDLE] Relay OFF");

  // Always attempt to turn relay on
  setRelay(true);
  state = STATE_RELAY_ON;
}


void handleRelayOn(float avgI1) {
  Serial.println("[STATE_RELAY_ON] Relay ON");

  bool ignoreInrush = (millis() - lastRelayOnTime < inrushIgnoreMs);

  if (!ignoreInrush && avgI1 >= trip_mA) {
    Serial.println(">>> TRIPPED <<<");
    setRelay(false);
    state = STATE_TRIPPED;
  }
}


void handleTripped(float avgI1) {
  Serial.println("[STATE_TRIPPED] Overcurrent");

  if (avgI1 <= reset_mA) {
    Serial.println(">>> RESET <<<");
    setRelay(true);
    state = STATE_RELAY_ON;
  }
}


// ------------ MAIN LOOP ------------
void loop() {
  // --- Check for PS5 commands via Serial ---
  if (Serial1.available()) {
    String cmd = Serial1.readStringUntil('\n');
    cmd.trim();

    if (cmd == "ON") {
      setRelay(true);
      offReason = NONE;          // clear PS5 override
      state = STATE_RELAY_ON;
      Serial.println("[Nano] Relay ON by PS5");
    } 
    else if (cmd == "OFF") {
      setRelay(false);
      offReason = PS5_OFF;       // PS5 forced OFF
      state = STATE_IDLE;
      Serial.println("[Nano] Relay OFF by PS5");
    }
  }

  // --- Sample INA219 sensors ---
  float avgI1 = 0, avgV1 = 0, avgP1 = 0;
  float avgI2 = 0, avgV2 = 0, avgP2 = 0;

  bool ready = sampleSensors(avgI1, avgV1, avgP1, avgI2, avgV2, avgP2);
  if (!ready) return;

  // --- Relay state machine ---
  switch (state) {
    case STATE_IDLE:
      // Only auto turn ON if relay was off due to overcurrent
      if (offReason == OVERCURRENT) handleIdle(avgI1);
      break;

    case STATE_RELAY_ON:
      if (avgI1 >= trip_mA) {
        Serial.println(">>> OVERCURRENT TRIP <<<");
        setRelay(false);
        offReason = OVERCURRENT;
        state = STATE_TRIPPED;
      }
      break;

    case STATE_TRIPPED:
      if (avgI1 <= reset_mA && offReason == OVERCURRENT) {
        Serial.println(">>> AUTO RESET <<<");
        setRelay(true);
        offReason = NONE;
        state = STATE_RELAY_ON;
      }
      break;
  }
}

