#include <Wire.h>
#include <Adafruit_INA219.h>

// ---------------- INA219 Sensors ----------------
Adafruit_INA219 ina1(0x40);
Adafruit_INA219 ina2(0x41);

// ---------------- Relay Settings ----------------
const int relayPin = 7;
const bool relayActiveLow = false;

const float trip_mA = 160.0;
const unsigned long inrushIgnoreMs = 500;
const unsigned long relayOffMinMs = 2000;
const int tripSampleCount = 100;

int overcurrentCounter = 0;
unsigned long lastRelayOnTime = 0;
unsigned long lastRelayOffTime = 0;

// ---------------- Averaging Variables ----------------
float totalBus1 = 0, totalCurrent1 = 0, totalPower1 = 0;
float totalBus2 = 0, totalCurrent2 = 0, totalPower2 = 0;
int sampleCount = 0;

float instI1 = 0;

// ---------------- State Machine ----------------
enum SystemState { STATE_RELAY_ON, STATE_TRIPPED };
SystemState systemState = STATE_RELAY_ON;


// ===================================================
//                   RELAY CONTROL
// ===================================================
void setRelay(bool on) {
  digitalWrite(relayPin, relayActiveLow ? !on : on);
  if (on) lastRelayOnTime = millis();
  else    lastRelayOffTime = millis();
}


// ===================================================
//                   TASK: SENSOR READ (1 kHz)
// ===================================================
void taskSample() {
  float v1 = ina1.getBusVoltage_V();
  float i1 = ina1.getCurrent_mA();
  float p1 = ina1.getPower_mW();

  float v2 = ina2.getBusVoltage_V();
  float i2 = ina2.getCurrent_mA();
  float p2 = ina2.getPower_mW();

  // Update globals
  instI1 = i1;

  totalBus1     += v1;
  totalCurrent1 += i1;
  totalPower1   += p1;

  totalBus2     += v2;
  totalCurrent2 += i2;
  totalPower2   += p2;

  sampleCount++;
}


// ===================================================
//                TASK: RELAY STATE MACHINE (2 ms)
// ===================================================
void taskRelay() {
  switch (systemState) {

    case STATE_RELAY_ON:
      if (instI1 >= trip_mA)
        overcurrentCounter++;
      else
        overcurrentCounter = 0;

      if (overcurrentCounter >= tripSampleCount &&
          (millis() - lastRelayOnTime > inrushIgnoreMs)) {

        Serial.println(">>> OVERCURRENT TRIP <<<");
        setRelay(false);
        systemState = STATE_TRIPPED;
        overcurrentCounter = 0;
      }
      break;


    case STATE_TRIPPED:
      if (millis() - lastRelayOffTime >= relayOffMinMs) {
        Serial.println(">>> AUTO RESET <<<");
        setRelay(true);
        systemState = STATE_RELAY_ON;
      }
      break;
  }
}


// ===================================================
//             TASK: AVERAGING + SERIAL OUTPUT
//            Executes every 3 seconds
// ===================================================
void taskAverages() {
  if (sampleCount == 0) return;

  float avgV1 = totalBus1     / sampleCount;
  float avgI1 = totalCurrent1 / sampleCount;
  float avgP1 = totalPower1   / sampleCount;

  float avgV2 = totalBus2     / sampleCount;
  float avgI2 = totalCurrent2 / sampleCount;
  float avgP2 = totalPower2   / sampleCount;

  // Reset accumulators
  totalBus1 = totalCurrent1 = totalPower1 = 0;
  totalBus2 = totalCurrent2 = totalPower2 = 0;
  sampleCount = 0;

  Serial.println("----- 3 Second Averages -----");
  Serial.print("INA1 Avg V: "); Serial.println(avgV1);
  Serial.print("INA1 Avg I: "); Serial.println(avgI1);
  Serial.print("INA1 Avg P: "); Serial.println(avgP1);

  Serial.print("INA2 Avg V: "); Serial.println(avgV2);
  Serial.print("INA2 Avg I: "); Serial.println(avgI2);
  Serial.print("INA2 Avg P: "); Serial.println(avgP2);
  Serial.println("-----------------------------");

  Serial1.print(avgV1); Serial1.print(",");
  Serial1.print(avgI1); Serial1.print(",");
  Serial1.print(avgP1); Serial1.print(",");
  Serial1.print(avgV2); Serial1.print(",");
  Serial1.print(avgI2); Serial1.print(",");
  Serial1.println(avgP2);
}


// ===================================================
//                 SCHEDULER STRUCTURE
// ===================================================
struct Task {
  unsigned long interval_us;
  unsigned long lastRun_us;
  void (*function)();
};

Task tasks[] = {
  {1000,     0, taskSample},   // 1 kHz
  {2000,     0, taskRelay},    // 2 ms
  {3000000,  0, taskAverages}  // 3 seconds
};

const int NUM_TASKS = sizeof(tasks)/sizeof(tasks[0]);


// ===================================================
//                        SETUP
// ===================================================
void setup() {
  Serial.begin(115200);
  Serial1.begin(115200);

  pinMode(relayPin, OUTPUT);
  setRelay(true);

  if (!ina1.begin()) { Serial.println("INA1 FAIL"); while(1); }
  if (!ina2.begin()) { Serial.println("INA2 FAIL"); while(1); }

  ina1.setCalibration_32V_2A();
  ina2.setCalibration_32V_2A();

  Serial.println("System Ready â€” Non-RTOS Scheduler Running");
}


// ===================================================
//                     MAIN LOOP
// ===================================================
void loop() {
  unsigned long now = micros();

  for (int i = 0; i < NUM_TASKS; i++) {
    if (now - tasks[i].lastRun_us >= tasks[i].interval_us) {
      tasks[i].lastRun_us = now;
      tasks[i].function();
    }
  }
}